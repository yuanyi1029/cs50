---------------------------- Abstract Data Structures -------------------------
Stacks and Queues are abstract data structures
Stacks are Last In First Out (LIFO)
Queues are First In First Out (FIFO)

4 new data structures:
1) Arrays
2) Linked lists
3) Hash tables (array of linked lists)
4) Tries (trees of array nodes)

Arrays:
Bad insertion and deletion
Good lookup (constant running time of O(1)) 
Easy to sort
Small size (takes up little memory)
Fixed size, not flexible

Linked lists:
Good insertion and deletion 
Bad lookup (can only use linear search with running time of O(n))
Hard to sort
Small size (but takes more memory than arrays)
No fixed size, flexible

Hash tables:
Good insertion and deletion
Good lookup (constant running time of O(1)) 
Sorting is not required or ideal
Big size 
No fixed size, flexible

Tries:
Good insertion and deletion
Good lookup (constant running time of O(1)) 
Already sorted
Big size
No fixed size, flexible

-------------------------------- Resizing Arrays ------------------------------ 
2 ways to resize an array:
1) Use realloc() to re-allocate a larger chunk of memory to store the larger array
2) Use linked lists that link each element with pointers 

---------------------------------- Linked Lists -------------------------------
Linked Lists are a new type of data structure 
Similar to array but elements are not stored next to each other, elements are
stored at different memory locations linked together with pointers
When resizing an array, each elements of a linked list points to the address of 
another element in the memory without the need to copying and moving the entire array 

Defining a linked list:
typedef struct node
{
    int number
    struct node *next_node       // next_node will be a pointer to the next node
}
node;

5 Steps to Initialise a linked list:
1) Declare a list pointer of NULL
2) Assign a node pointer to malloc(sizeof(node)) 
   node *n = malloc(sizeof(node))   // malloc() will return the address of a memory chunk 
3) Set the node variable values
   // Go to the address of n, then go to the number variable of the node and set it to 1
   (*n).number = 1      OR       n -> number = 1
   // next_node will be NULL because the next node is not created yet
   (*n).next_node = NULL    OR      n -> next_node = NULL
4) Make the list pointer point to same location as the node pointer (point to first node)
   list = n   
5) Repeat step 2 - 4 to add another node, but for step 3, next_node should point to the
   same location as list
   // Since list is pointing to the first node, the new node should also point to 
   // the first node
   (*n).next_node = list    OR      n -> next_node = list

Note:
When the second node is created, its next_node variable will be made to point to the 
first node. Therefore this is a stack type data structure where the newest nodes are 
at the top (Last in First Out, LIFO)
   

Downsides to linked lists:
1) Takes up more memory than arrays (to store the pointers)
2) Unable to use indexing to get an element + Unable to use binary search

Searching for an element in a linked list has a running time of O(n)
 
------------------------------------- Trees -----------------------------------
Trees are a new type of data structure
Similar to linked lists but each elements are linked with pointers in a 
hierarchical manner

Binary Search Trees:
Trees that are linked with pointers in a hierarchical manner that allow binary
search where the root's left nodes are smaller elements while the root's right
nodes are larger elements

Defining a binary search tree:
typedef struct node
{
    int number
    struct node *left_node
    struct node *right_node
}
node;


Downsides to trees:
1) Takes up more memory than linked lists (to store left and right node pointers)

Searching for an element in a binary search tree has a running time of O(log n)
     

Tries:
Tries are trees in which each node is an array 
Searching for an element in a try has a running time of O(1)    (constant time)

---------------------------------- Dictionaries -------------------------------
Dictionaries are a new type of data structure
Dictionaries are different from linked lists and trees where elements are stored
with a key and value pair 

----------------------------------- Hashing -----------------------------------
The process of receiving an input value and producing a simpler output
Hash functions are algorithms that implement hasing
Hash tables are a new type of data structure which is an array of linked lists 
Searching for an element in a hash table has a running time of O(1)    (constant time)

 

