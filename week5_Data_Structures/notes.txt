---------------------------- Abstract Data Structures -------------------------
Stacks and Queues are abstract data structures
Stacks are Last In First Out (LIFO)
Queues are First In First Out (FIFO)

-------------------------------- Resizing Arrays ------------------------------ 
2 ways to resize an array:
1) Use realloc() to re-allocate a larger chunk of memory to store the larger array
2) Use linked lists that link each element with pointers 

---------------------------------- Linked Lists -------------------------------
Linked Lists are a new type of data structure 
Similar to array but elements are not stored next to each other, elements are
stored at different memory locations linked together with pointers
When resizing an array, each elements of a linked list points to the address of 
another element in the memory without the need to copying and moving the entire array 

Defining a linked list:
typedef struct node
{
    int number
    struct node *next_node       // next_node will be a pointer to the next node
}
node;

5 Steps to Initialise a linked list:
1) Declare a list pointer of NULL
2) Assign a node pointer to malloc(sizeof(node)) 
   node *n = malloc(sizeof(node))   // malloc() will return the address of a memory chunk 
3) Set the node variable values
   // Go to the address of n, then go to the number variable of the node and set it to 1
   (*n).number = 1      OR       n -> number = 1
   // next_node will be NULL because the next node is not created yet
   (*n).next_node = NULL    OR      n -> next_node = NULL
4) Make the list pointer point to same location as the node pointer (point to first node)
   list = n   
5) Repeat step 2 - 4 to add another node, but for step 3, next_node should point to the
   same location as list
   // Since list is pointing to the first node, the new node should also point to 
   // the first node
   (*n).next_node = list    OR      n -> next_node = list

Note:
When the second node is created, its next_node variable will be made to point to the 
first node. Therefore this is a stack type data structure where the newest nodes are 
at the top (Last in First Out, LIFO)
   

Downsides to linked lists:
1) Takes up more memory than arrays (to store the pointers)
2) Unable to use indexing to get an element + Unable to use binary search

------------------------------------- Trees -----------------------------------
Trees are a new type of data structure
Similar to linked lists but each elements are linked with pointers in a 
hierarchical manner

Binary Search Trees:
Trees that are linked with pointers in a hierarchical manner that allow binary
search where the root's left nodes are smaller elements while the root's right
nodes are larger elements

Defining a binary search tree:
typedef struct node
{
    int number
    struct node *left_node
    struct node *right_node
}
node;


Downsides to trees:
1) Takes up more memory than linked lists (to store left and right node pointers)


Tries:
Tries are trees in which each node is an array 

---------------------------------- Dictionaries -------------------------------
Dictionaries are a new type of data structure
Dictionaries are different from linked lists and trees where elements are stored
with a key and a value 

Hashing:
----------------------------------- Hashing -----------------------------------
The process of receiving an input value and producing a simpler output
Hash functions are algorithms that implement hasing
Hash tables are a new type of data structure which uses arrays and linked lists 

-----------------------------------  -----------------------------------






Sorting Algorithms sorts an array of elements

Types of Algorithms for sorting:
1) Selection Sort - sorting by finding smallest and place it accordingly
2) Bubble Sort  - sorting by comparing 2 elements and swap places, repeat until sorted 
3) Merge Sort - sorting 2 halves and compare the smallest element of each halve

Selection Sort:
Loops through the entire array, look for the smallest element and swap places
with the first element of the unsorted part 

Bubble Sort:
Loops through the array constantly checking between 2 elements and swap places if
the elements are in the wrong order, repeat this process until the array is sorted
(generally moves high values to the right and low values to the left)

Merge Sort:
Sort 2 halves of the array, compare the smallest element of each halve, then
get the smallest element and put it in a new array 


-------------------------------- Running Time ---------------------------------
All algorithms have a running time which represents roughly how fast / slow the algorithm is
(represented by O)

Slowest to Fastest running times:  
O(n ^ 2) > O(n log n) > O(n) > O(log n) > O(1)          

Linear search has a running time of O(n)
Binary search has a running time of O(log n)

Linear sort has a running time of O(n ^ 2) 
Bubble sort has a running time of O(n ^ 2)           
Bubble sort has a running time of O(n log n)         



Data structures are a specialized way of storing and processing data 
Arrays are a type of data structure that allows us to store data back-to-back
Modern programming languages allows us to invent our own data structures

Implementing a new data structure:
    typedef struct
    {
        // variables
    }
    structure_name








Hexadecimal format is a concise way to express memeory on a computer system
represented with 0x at the front (0x10, 0xA6, 0xFF)
Hexadecimal is base 16 where 2 hex digits can represent up to decimal of 255 or 8 bits (1 byte)
0xFF = 11111111 = 255

Operators related to memory:
&           (Used to get the memory address of a variable)
*           (Used to go to a memory address)

Functions related to memory:
malloc()    (Request a chunk of space)
free()      (Free up the chunk of space when finished using it)
scanf()     (Get input from the user)

Examples:
    int *p = &n

    int *x = malloc(4)

    int y;
    printf("y: ")
    scanf("%i", &y)

p is an address variable (pointer) that stores the address of an integer variable n
x in an address variable (pointer) than can point to 4 bytes of memory
scanf gets the user input and stores it at the address of y 

----------------------------------- Pointers ---------------------------------- 
Pointers are just addresses of variables 
Pointers can be used to pass actual values of variables into functions (previously impossible)

The '*' can also be used:
1) To initialise a variable as a pointer
    int *x = &10;
2) To go to the reference and access the data
    printf("%i\n",*x)     // Go to the address of x and print the value

When not setting a pointer immediately, always set pointers to NULL first
    int *x = NULL 
 
----------------------------- Pointers with strings --------------------------- 
The variable that stores a string is just storing the address of the first character
of that string. (Same with arrays as well)

Therefore:
string s = "HI"     is the same as     char *s = "HI!"

Using arithmetic with pointers:    
*s              // Go to memory address of s        
*(s + 1)        // Go to the next memory address of s 

Comparing strings:
We cannot use "==" when comparing string variables because the 2 variables may
have the same contents, but the variables have different addresses so it would 
never be equal.
Solution: Use strcmp(s,t) == 0
    char *s = "HI!"
    char *t = "HI!"
    s == t              (false because s and t have different addresses) 

Copying strings:
When assigning a variable to a string, that variable only stores a copy of 
the string's address where changing one of s or t will result in changes in both
    char *s = "HI!"     (s stores the address of the first character of "HI!")
    char *t = s         (t makes a copy of s which is just the address of "HI!")
Solution: Use malloc() from stdlib library to get a chunk of space and strcpy() 
          to copy the string
    char *s = "HI!"
    char *t = malloc(4)  // 4 because we need \0 at the end (HI!\0)
    strcpy(t, s)

------------------------------ Pointers with Files ---------------------------- 
Initialise a variable as a file pointer with FILE * 

File functions:
fopen()     // Opens a file
fclose()    // Close a file 
fgetc()     // Reads and returns the next character of the pointed file
fputc()     // Writes or appends a character to the pointed file
fread()     // Reads a number of units of a certain size from a certain file and
            // stores them in a buffer (usually an array)
fwrite()    // Writes a number of units of a certain size from a certain file from
            // a buffer (usually an array)
Example:
FILE *my_file = fopen(filename, "r")        // "r" is the operation to read the file only
fclose(file_pointer)                        // Close the file
char y = fgetc(file_pointer)                // get the next character of a file, store it in y
fputc('A', file_pointer)                    // Write 'A' to a file
fread(array, sizeof(int), 10, file_pointer) // Read from file of 40 bytes (4 x 10 times) and 
                                            // store it into an array
fwrite(array, sizeof(int), 10, file_pointer)// Write 40 bytes (4 x 10 times) into a file of 
                                            // from the array 
